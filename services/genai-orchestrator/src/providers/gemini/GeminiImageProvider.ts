import { GoogleGenAI } from '@google/genai'
import { Logger } from '@aws-lambda-powertools/logger'

import type { ModelConfig } from '@auteurium/shared-types'
import type { IImageProvider, ImageGenerationRequest, ImageGenerationResponse } from '../base/IImageProvider'
import { getModelsByProvider } from '../../config/models'
import { ModelProvider, GenerationModality } from '@auteurium/shared-types'

const logger = new Logger({ serviceName: 'gemini-image-provider' })

/**
 * Gemini Imagen provider implementation
 * Uses Google Gen AI SDK for Imagen 4 image generation
 */
export class GeminiImageProvider implements IImageProvider {
  readonly name = 'gemini-image'
  private client: GoogleGenAI | null = null
  private apiKey: string | null = null

  async initialize(apiKey: string): Promise<void> {
    this.apiKey = apiKey
    this.client = new GoogleGenAI({ apiKey })
    logger.info('Gemini Image provider initialized')
  }

  async generate(): Promise<never> {
    throw new Error('Image provider does not support text generation. Use generateImage() instead.')
  }

  async generateImage(request: ImageGenerationRequest): Promise<ImageGenerationResponse> {
    if (!this.client) {
      throw new Error('Gemini Image provider not initialized. Call initialize() first.')
    }

    const startTime = Date.now()

    try {
      // Validate prompt
      await this.validatePrompt(request.prompt)

      const aspectRatio = request.width && request.height
        ? `${request.width}:${request.height}`
        : '1:1'

      logger.info('Generating image with Imagen', {
        modelId: request.modelId,
        promptLength: request.prompt.length,
        aspectRatio
      })

      // Generate image using Imagen API
      const response = await this.client.models.generateImages({
        model: request.modelId,
        prompt: request.prompt,
        config: {
          numberOfImages: 1,
          aspectRatio
        }
      })

      if (!response || !response.generatedImages || response.generatedImages.length === 0) {
        throw new Error('No image generated by Imagen')
      }

      const generatedImage = response.generatedImages[0]

      // Extract image data - Imagen returns image in 'image' property
      let imageData: unknown

      if (generatedImage.image) {
        const img = generatedImage.image as Record<string, unknown>

        // Try different properties that might contain the image data
        if (img.imageBytes) {
          imageData = img.imageBytes
        } else if (img.data) {
          imageData = img.data
        } else {
          // The image object itself might be the data
          imageData = generatedImage.image
        }
      }

      if (!imageData) {
        throw new Error('Image data is empty or has unexpected structure')
      }

      // Parse aspect ratio to get dimensions
      const [widthRatio, heightRatio] = aspectRatio.split(':').map(Number)
      const baseSize = 1024
      const width = aspectRatio === '1:1' ? baseSize : Math.round(baseSize * widthRatio / Math.max(widthRatio, heightRatio))
      const height = aspectRatio === '1:1' ? baseSize : Math.round(baseSize * heightRatio / Math.max(widthRatio, heightRatio))

      const generationTimeMs = Date.now() - startTime
      const cost = this.calculateCost(1, request.modelId) // Fixed cost per image

      logger.info('Image generation completed', {
        modelId: request.modelId,
        cost,
        generationTimeMs,
        width,
        height
      })

      return {
        image: {
          type: 'image',
          url: '', // Will be set after S3 upload
          s3Key: '', // Will be set after S3 upload
          metadata: {
            width,
            height,
            aspectRatio,
            format: 'png',
            generatedAt: new Date().toISOString()
          }
        },
        imageData, // Include raw image data for upload
        tokensUsed: 1, // Imagen charges per image, not tokens
        cost,
        modelUsed: request.modelId,
        generationTimeMs
      } as ImageGenerationResponse & { imageData: unknown }
    } catch (error) {
      logger.error('Image generation failed', {
        error: error instanceof Error ? error.message : String(error),
        modelId: request.modelId
      })
      throw error
    }
  }

  async getAvailableModels(): Promise<ModelConfig[]> {
    const models = getModelsByProvider(ModelProvider.GEMINI)
    return models.filter(model => model.modality === GenerationModality.TEXT_TO_IMAGE)
  }

  isModelSupported(modelId: string): boolean {
    const models = getModelsByProvider(ModelProvider.GEMINI)
    return models.some(model => model.modelId === modelId && model.modality === GenerationModality.TEXT_TO_IMAGE)
  }

  calculateCost(imagesGenerated: number, modelId: string): number {
    const models = getModelsByProvider(ModelProvider.GEMINI)
    const model = models.find(m => m.modelId === modelId)

    if (!model || !model.costPerToken) {
      logger.warn('Cost per image not configured for model', { modelId })
      return 0
    }

    // For Imagen, costPerToken represents cost per image
    return imagesGenerated * model.costPerToken
  }

  async validatePrompt(prompt: string): Promise<boolean> {
    if (!prompt || prompt.trim().length === 0) {
      throw new Error('Prompt cannot be empty')
    }

    // Imagen has a 480 token limit (approximately 1920 characters)
    if (prompt.length > 1920) {
      throw new Error('Prompt exceeds maximum length of 480 tokens (~1920 characters)')
    }

    return true
  }

  getSupportedSizes(): Array<{ width: number; height: number }> {
    return [
      { width: 1024, height: 1024 }, // 1:1
      { width: 768, height: 1024 },  // 3:4
      { width: 1024, height: 768 },  // 4:3
      { width: 576, height: 1024 },  // 9:16
      { width: 1024, height: 576 }   // 16:9
    ]
  }
}
